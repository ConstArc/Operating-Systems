Α.Μ: sdi2100008
Ο/Ε: Κωνσταντίνος Αρκουλής

Η εργασία αυτή αφορά την 3η εργασία του μαθήματος:

		Κ22 Λειτουργικά Συστήματα της σχολής Πληροφορικής και Τηλεπικοινωνιών ΕΚΠΑ
	Ακαδημαϊκό έτος 2023-2024, χειμερινό εξάμηνο -τμήμα Αρτίων. Διδάσκων: κ. Αλέξης Δελής

	___NOTE___
	Η συγγραφή του συγκεκριμένου Readme.txt, έγινε μέσα από το VSCODE IDE.
	Επομένως, για προβλήματα στην μορφοποίηση/στοίχιση του κειμένου, προτείνεται
	η ανάγνωση μέσα από το ίδιο IDE (κατά προτίμηση σε fullscreen)

	___ΣΗΜΑΝΤΙΚΟ___
		 		   \
		  	        ν
	!!! Έχουν υλοποιηθεί όλα τα ζητούμενα της εργασίας !!!

Περιεχόμενα:
	Α)  Εκτέλεση προγράμματος και Makefile  				γραμμή 28
	Β)  Σύντομη περιγραφή αρχιτεκτονικής κώδικα 	   		γραμμή 86
	Γ)  Σχεδιαστικές επιλογές / Παραδοχές  					γραμμή 124
	Δ)  Επεξήγηση Συγχρονισμού								γραμμή 203
	Ε)  Αιτιολόγηση ορθότητας λύσης στο πρόβλημα του CS		γραμμή 302
	ΣΤ) Τεχνικές λεπτομέρειες 								γραμμή 350


Α) Εκτέλεση προγράμματος και Makefile

--> Προϋποθέτουμε ότι ο χρήστης είναι στο parental folder της εργασίας, δηλαδή στο ίδιο folder που βρίσκεται και το Makefile.

--> Το Makefile έχει φτιαχτεί με τέτοιο τρόπο ώστε να κάνει separate compilation (όπως ζητείται εξάλλου και από την εκφώνηση). 
	Για την δημιουργία του, έχω συμβουλευτεί διάφορες πηγές στο διαδίκτυο, με ίσως την πιο σημαντική να είναι η:
		https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/

--> Η αλλαγή του testfile που θα δοθεί στο πρόγραμμα για ανάγνωση/επεξεργασία καθώς και του αριθμού των συνολικών workers 
	(reader/writer) processes που θα γίνουν forked από τον initlzer (initializer) γίνεται στο Makefile. Οι έννοιες αυτές
	θα εξηγηθούν επαρκώς παρακάτω.

--> Το folder structuring έχεις ως εξής:
	* bin:  	  μετά το compilation του κώδικα, τοποθετούνται όλα τα αντικειμενικά αρχεία (.o) και τα εκτελέσιμα αρχεία.
	* include:    εδώ περιέχονται όλα τα header (.h) αρχεία του κώδικα
	* src: 	      τα αρχεία πηγαίου κώδικα (.src)
	* log:	      τοποθετούνται τα αρχεία Logs.log και Errors.log που περιγράφονται παρακάτω.
	* valout:     τοποθετούνται τα αρχεία "[PID].log" που περιέχουν το log του εργαλείου valgrind για το συγκεκριμένο
	process, αν επιλεχθεί η εκτέλεση με valgrind για έλεγχο για memory leaks (λεπτομέρειες παρακάτω).
	* SampleData: εδώ πέρα βρίσκονται τα παραδείγματα που συνοδεύουν την εργασία, μαζί με τα υπόλοιπα αρχεία Verify.c τα οποία
	δεν τροποποιούμε.
	* tests:   	  όμοια με το SampleData, στο directory αυτό περιέχονται ως αντίγραφα, όλα τα αρχεία του SampleData, τα οποία,
	όμως, μπορεί να αλλοιωθούν κατά την εκτέλεση του προγράμματος, λόγω των writers.

--> Το αρχείο Logs.log που δημιουργείται στην εκτέλεση του προγράμματος περιέχει και ενημερώνεται συνεχώς κατά την εκτέλεση, 
	τα logs με τα στατιστικά που κρατάμε για την κατάσταση του συστήματος, περισσότερα παρακάτω.

--> Το αρχείο Errors.log που δημιουργείται, περιέχει, αν υπάρξουν (ελπίζουμε πως όχι) errors σχετικά με την εκτέλεση του 
	προγράμματος.

--> Για απλή εκτέλεση χωρίς έλεγχο για memory leaks:
	$ make run

--> Για εκτέλεση με έλεγχο για memory leaks:
	$ make valgrind

	> Η επιλογή αυτή δεν ενδείκνυται για μεγάλο αριθμό από processes (π.χ. πάνω από 100) καθώς το μηχάνημα επιβάρυνεται
	αρκετά για την δημιουργια των αρχείων "[PID].log" στο valout και από το ίδιο το valgrind.

								___  Δίνει το instance της κατάστασης του registry του συστήματος εκείνη την χρονική στιγμή.
							   /	 (περισσότερες λεπτομέρειες για τον logger και την διαφορά του με τον accountant, παρακάτω)
							  v
--> Για εκτέλεση στιγμιαίου logger (σε διαφορετικό tty):
	$ make run_logger

--> Για καθαρισμό των αρχείων στο bin, valout, log:
	$ make clean

--> Για καθαρισμό του shared memory segment, σε περίπτωση που το πρόγραμμα τερματίσει βίαια:
	$ make clean_shmem

--> Για "reset" στα αρχεία test του tests directory:
	$ make clean_tests

--> Είτε μέσω της εκτέλεσης make run είτε μέσω της εκτέλεσης make valgrind, πρώτα, γίνεται ένα clean στον φάκελο log εσωτερικά από τα
	ίδια αυτά rules (στο make valgrind, καθαρίζεται επίσης και το folder valout).


Β) Σύντομη περιγραφή αρχιτεκτονικής κώδικα
--> Βοηθητικά modules
	* inputUtils   (inputUtils.c - inputUtils.h):     Βοηθητικές συναρτήσεις για το parsing των command line arguments στα processes
	* record       (record.c - record.h):			  Δομή και βοηθητικές συναρτήσεις για τα records ενός αρχείου
	* processUtils (processUtils.c - processUtils.h): Βοηθητικές συναρτήσεις για τα processes

--> Κοινά και καίριας σημασίας modules
	* shmem        (shem.c - shmem.h):				  Δομή shared memory segment και σχετικές συναρτήσεις (initilization/destroy κτλπ.)
	* synchroUtils (synchroUtils.c - synchroUtils.h): Βοηθητικές συναρτήσεις σχετικά με τον συγχρονισμό των processes

--> Modules "οντότητες"
	* initlzer (initlzer.c - initlzerUtils.c - initlzer.h)
		> Αφορά το εκτελέσιμο από τον χρήστη πρόγραμμα, που ευθύνη αυτού είναι να αρχικοποιήσει τις δομές του shared memory, να
		δημιουργήσει τον accountant και να κάνει fork τους workers, δηλαδή τους readers και τους writers.
		> Στο τέλος, εκτυπώνει τα στατιστικά που αναφέρονται και στην εκφώνηση ("ως στατιστικά πριν την λήξη του προγράμματος")
		> Χρησιμοποιείται τυχαιότητα για τον αν θα δημιουργηθεί reader ή writer κάθε φορά με αυτά τα δύο ενδεχόμενα να είναι
		ισοπίθανα.
		> Χρησιμοποιείται επίσης τυχαιότητα για την αρχικοποιήση των command line arguments των workers (περισσότερα στον κώδικα).

	* logging (accountant.c - logger.c - loggingUtils.c - logging.h)
		> Σε αυτό το module περιέχεται οτιδήποτε σχετικό με το logging των προγραμμάτων.
		> Συγκεκριμένα, εδώ βρίσκονται τα εκτελέσιμα accountant.c και logger.c με τις βοηθητικές τους συναρτήσεις (loggingUtils)
		> Ο accountant είναι το process που παραμένει ενεργός καθόλη την διάρκεια εκτέλεσης του προγράμματος και η δουλειά του
		είναι να εκτυπώνει στο παραγώμενο αρχείο Logs.log, την κατάσταση του συστήματος (registry) κάθε φορά που:
			i)  Εισέρχεται στο σύστημα (πιθανώς και στο critical section) ένας worker.
			ii) Εξέρχεται από το critical section ένας worker.
		Επιπλέον, ο accountant εκτυπώνει κάθε φορά στην αρχή και ένα ενημερωτικό μήνυμα, που αφορά το process που εισέρχεται/εξέρχεται.
		> Ο logger είναι η διεργασία που μπορεί να εκτελέσει ο χρήστης από ένα δεύτερο terminal για να δει την κατάσταση του συστήματος
		(registry) εκείνη την χρονική στιγμή. Σε αντίθεση με τον accountant, ο logger δεν εκτυπώνει κάποιο μήνυμα στην αρχή. Επιπλέον,
		αφού ο logger φέρει εις πέρας την δουλεία του τερματίζει και μπορεί να επανακληθεί.

	* reader (reader.c - readerUtils.c - reader.h)
		> Η διεργασία αναγνώστης της εργασίας αυτής (reader.c) μαζί με τις βοηθητικές συναρτήσεις του (readerUtils.c).

	* writer (writer.c - writerUtils.c - writer.h)
		> Η διεργασία συγγραφέας της εργασίας αυτής (writer.c) μαζί με τις βοηθητικές συναρτήσεις του (writerUtils.c).


Γ) Σχεδιαστικές επιλογές / Παραδοχές

--> Έχει χρησιμοποιηθεί το POSIX Shared-Memory-IPC API (αντί του System V IPC) για το shared memory, την αρχικοποίηση του και άλλες
	σχετικές λειτουργίες του. Οι σύνδεσμοι που συμβουλεύτηκα είναι:

		1) https://www.geeksforgeeks.org/posix-shared-memory-api/
		2) https://man7.org/linux/man-pages/man3/shm_open.3.html

	Μάλιστα, στον δεύτερο σύνδεσμο (manual) βρήκα και ένα παράδειγμα το οποίο ακολούθησα πιστά για την υλοποίηση των shmem_*()
	συναρτήσεων του shmem module. Επιπλέον, από εκεί πήρα το macro errExit (global.h) καθώς μου άρεσε ο τρόπος με τον οποίο σου
	επιτρέπει να έχεις ';' στο τέλος, παρόλο που είναι macro.

--> Η προσέγγιση που έχει ακολουθηθεί για την εκτέλεση του προγράμματος στην συγκεκριμένη υλοποίηση, είναι αυτή με την χρήση
	forks()/exec*() και συγκεκριμένα έχει χρησιμοποιηθεί η execl() λόγω της απλότητας της που αρμόζει στις ανάγκες μας.
		* Συγκεκριμένα, ο χρήστης εκτελεί το πρόγραμμα initlzer με αρχικές παραμέτρους -f και -n. Το -f flag
		αρχικοποιείται με το όνομα του test-file που θα επεξεργαστούν οι writers και θα διαβάσουν οι readers. Το -n flag
		αρχικοποιείται με τον συνολικό αριθμό από worker processes (readers/writers) που θα γίνουν spawned (forked) από τον
		initlzer.
		* Οι έννοιες αυτές θα αναλυθούν καλύτερα παρακάτω.
		* Για την δημιουργία και την αρχικοποίηση των παραμέτρων των worker processes χρησιμοποιείται τυχαιότητα. Τα ενδεχόμενα
		δημιουργίας reader ή της δημιουργίας writer είναι ισοπίθανα. Για την τροποποίηση ορισμένων τιμών που επηρεάζουν τις τελικές
		τιμές των παραμέτρων των workers (π.χ. την μέγιστη τιμή που μπορεί να πάρει το -v flag σε όλους του writers) μπορεί ο χρήστης
		να αλλάξει τις αντίστοιχες τιμές στα defines του initlzerUtils.h.
		* Λαμβάνοντας υπόψη αυτή την προσέγγιση (με τα forks) έχει επιλεχθεί μικρό sleep time στους workers για καλύτερη
		επίδειξη του συγχρονισμού των εργατών. Συγκεκριμένα, έχουν δοθεί οι τιμές max_time = [1, 4] για τους writers και
		max_time = [1, 8] για τους readers. Το τελικό sleep time ενός worker είναι στο [0, max_time]. Παρόλ' αυτά ο χρήστης μπορεί να
		τροποποιήσει το εύρος του max_time για κάθε process type, αρκεί να αλλάξει τις αντίστοιχες τιμές στα defines του initlzerUtils.h
		* Για χάριν απλότητας και λόγω συναρτήσεων ελέγχου αριθμών, όταν -κατά την αρχικοποίηση της παραμέτρου -l ενός reader- το 
		record_id_start είναι διαφορετικό από το record_id_finish, τότε το flag αυτό αρχικοποιείται ως εξής: 
			
			"... -l record_id_start , record_id_finish ...". 											 
								   ^ ^
	    						    \_\__NOTE_
			
			Δηλαδή, πρέπει να υπάρχει κενό πριν από το κόμμα και μετά.
		* Τέλος, πάλι για λόγους απλότητας, δεν έχει δοθεί η δυνατότητα στον χρήστη να αλλάξει εύκολα το εύρος των εγγραφών που θα
		διαβάσει ένας reader. Αυτό είναι fixed, ως ένα τυχαίο υποσύνολο του [first record of file, last record of file].

--> Για όλα τα time measurements που γίνονται στην παρούσα εργασία, χρησιμοποιείται η gettimeofday(), εσωτερικά των συναρτήσεων
	start_timer(), elapsed_time() και δηλαδή στην ουσία μετράμε real time. Επιλέχθηκε η gettimeofday(), παρόλο που ίσως δεν είναι
	η πιο ακριβής, λόγω της απλότητας και της λιτότητας της. Περισσότερα στο processUtils module.

--> Όπως διευκρινίστηκε και στο Piazza (@101) το waiting_time (για το στατιστικό ν.5 "Μέγιστη καθυστέρηση...είτε από συγγραφέα")
	είναι το time interval από την εισαγωγή της εκάστοτε διεργασίας στο σύστημα (αρχή της main), μέχρι την στιγμή που αυτή θα μπει
	στο κομμάτι κώδικα που επεξεργάζεται εγγραφές του αρχείου (αρχή του Critical Section).
	Ομοίως, το active time (για τα στατιστικά ν.2 και ν.4) της εκάστοτε διεργασίας, είναι ο συνολικός χρόνος από την αρχή της main()
	μέχρι την έξοδο της.

--> Τα στατιστικά που καταγράφονται είναι πάνω κάτω αυτά που αναφέρονται και στην εκφώνηση. Δηλαδή:
	* Πίνακας των διεργασίων που βρίσκονται στο σύστημα (workers/readers που είναι active/blocked)
	* Αριθμός από διεργασίες readers
	* Αριθμός από διεγασίες  writers
	* Μέγιστη αναμονή ενός worker από την στιγμή που εισήχθει στο σύστημα μέχρι να ξεκινήσει να
	κάνει process records.
	* Πέρα από αυτά που περιγράφονται στην εκφώνηση εκτυπώνεται και το πλήθος των records που
	έχουν επεξεργαστεί οι readers και -ξεχωριστά- οι writers καθώς και ένα ενημερωτικό μήνυμα της
	τελευταίας logging ενέργειας του συστήματος (το παρόν εξηγείται αναλυτικότερα ακριβώς από κάτω).
	* Περισσότερες λεπτομέρειες στην δομή registry του shmem.h

--> Επεξήγηση εκτύπωσης των στατιστικών που κρατάμε. Η εκτύπωση γίνεται από τον accountant στο αρχείο Logs.log του folder log.
	Ο accountant εκτυπώνει:
	* Ένα μήνυμα που αφορά την τελευταία δραστηριότητα εισαγωγής/εξαγωγής μιας διεργασίας εργάτης (αναγνώστης/συγγραφέας)
	μαζί με ορισμένες πληροφορίες για αυτή την διεργασία. Όπως ειπώθηκε προηγουμένως, το "εισαγωγής" εδώ αναφέρεται στην
	εισαγωγή στο σύστημα και, πιθανώς -αν το επιθυμητό range είναι ελεύθερο- στο ίδιο το critical section της διεργασίας
	αυτής. Με την "εξαγωγή" που αναφέρουμε παραπάνω, εννοούμε κατευθείαν μετά το τέλος της δουλειάς του εργάτη. Περισσότερα
	για αυτές τις έννοιες και για το τι είναι το critical section στα πλαίσια αυτής της εργασίας, στην ενότητα Δ) Επεξήγηση
	Συγχρονισμού.
	* Δύο πίνακες όπου κάθε στοιχείο έχει την μορφή (PID/Status) όπου το PID είναι το process id της διεργασίας worker
	και το Status παίρνει τις τιμές A (active) ή B (blocked) ανάλογα με το αν η εκάστοτε διεργασία έχει ξεκινήσει να
	κάνει επεξεργασία των records στο range της (active), περιμένει/έχει μπλοκαριστεί (blocked). Περισσότερα για το Status
	παρακάτω στην επεξήγηση του συγχρονισμού. Ο ένας από αυτούς τους πίνακες αναφέρεται συγκεκριμένα για τις διεγασίες
	αναγνώστης και ο άλλος για τις διεργασίες συγγραφέας.
	* Τον συνολικό αριθμό από αναγνώστες που έχουν τελειώσει την δουλειά τους με το αρχείο.
	* Τον συνολικό αριθμό από συγγραφείς που έχουν τελειώσει την δουλειά τους με το αρχείο.
	* Τον αριθμό από records που έχουν διαβάσεις οι readers.
	* Τον αριθμό από records που έχουν ενημερώσει οι writers.
	* Τον συνολικό αριθμό από records που έχουν επεξεργαστεί είτε αναγνώστες ή συγγραφείς.
	

Δ) Επεξήγηση Συγχρονισμού
	  
	__NOTE__: Για να γίνει αντιληπτός ο τρόπος με τον οποίο έχει υλοποιηθεί ο συγχρονισμός των συγγραφέων/αναγωστών,
	προτείνεται η ανάγνωση ολόκληρης αυτής της ενότητας, καθώς η σημασία αρκετών εννοιών -σταδιακά- μετασχηματίζεται
	σε κάτι πιο σύνθετο. Στο τέλος, ευελπιστώ να έχω εξηγήσει όσο γίνεται καλύτερα και να έχει γίνει κατανοητή, η
	προσέγγιση αυτή. Εννοείται, τα comments στον κώδικα του synchroUtils θα βοηθήσουν επίσης αρκετά στην κατανόηση.
	
	* Στόχος της εργασίας αυτής είναι η αντιμετώπιση των εγγραφών (records) ενός αρχείου ως το καθένα να είναι ένα shared
	resource/object, μεταξύ διεργασιών readers (αναγνώστες) και writers (συγγραφείς). Οι αναγνώστες μπορούν μόνο να
	διαβάσουν και να εκτυπώσουν ένα ή περισσότερα records, ενώ οι συγγραφείς μπορούν μόνο να ενημερώσουν την τιμή του
	υπολοίπου ενός και μόνο ενός record. Επομένως, θα πρέπει να μπορούν να λειτουργήσουν ταυτόχρονα ένας reader και ένας
	writer ή ένας writer και ένας άλλος writer, αρκεί να είναι σε διαφορετικές εγγραφές τα αρχείου. Προβληματικές
	περιπτώσεις σχετικά με τον συγχρονισμό των worker διεργασιών και το coherence των δεδομένων του αρχείου, θεωρούνται
	οι εξής:
		i)   Ένας writer θέλει να ενημερώσει μια εγγραφή την οποία ήδη διαβάζουν ένας ή και περισσότεροι readers.
		ii)  Ένας writer θέλει να ενημέρωσει μια εγγραφή την οποία ήδη ενημερώνει κάποιος άλλος writer.
		iii) Ένας reader θέλει να διαβάσει μια εγγραφή την οποία ήδη ενημερώνει κάποιος writer.
	
	* Η λογική που ακολουθείται στην παρούσα υλοποίηση αντιμετωπίζει τις προβληματικές περιπτώσεις ως εξής:
		> Κρατάμε στο shared memory έναν μονό-διάστατο πίνακα (conc_proc_arr) από struct proc_info (shmem.h) μεγέθους
		maximum concurrent processes (defined στο shmem.h) στο οποίο, μετά από κάποιες δοκιμές, έχει δοθεί η τιμή 256.
		> Επιπλέον, κρατάμε ένα ticket prioritization mechanism όπου, όταν κάθε διεργασία μπει στο σύστημα και πάρει το
		mutex, τότε, παίρνει και το ticket της και μειώνει την τιμή του κατά ένα. Δηλαδή, διεργασίες με μικρό prioritization
		σημαίνει ότι είναι "νεότερες" για το σύστημα, ενώ με μεγάλο prioritization είναι "γηραιότερες" για το σύστημα.
		> Έπειτα, κοιτάζει το παραπάνω array και βρίσκει μια κενή θέση για να κάνει inhabit (το πεδίο index είναι -1 στις
		κενές θέσεις) και αρχικοποιεί το proc_info της με το range από εγγραφές πάνω στις οποίες θέλει να δουλέψει (για
		τους writers αυτό θα είναι απλά της μορφής [x,x] όπου x το index της εγγραφής που θέλει να ενημέρωσει).
		> Έχει κρατηθεί και ένα semaphore conc_proc (concurrent processes) με το value του αρχικοποιημένο στην ίδια τιμή
		με το μέγεθος του πίνακα και, έτσι, μόλις εισαχθεί στο σύστημα ένας worker (πριν δηλαδή πάρει το mutex και το
		ticket της), κάνει πρώτα P signal στο semaphore αυτό, και λίγο πριν βγει από την εκτέλεση του, κάνει πρώτα V signal
		στο ίδιο semaphore. Έτσι, εξασφαλίζεται ότι πάντα μια διεργασία θα βρει -μόλις πάρει το mutex- μια κενή θέση στον 
		πίνακα για να κάνει occupy.
		> Μετά, καθώς έχει το mutex, κοιτάζει όλο το παραπάνω array (προφανώς τις θέσεις που είναι inhabited, εκτός
		από την δική του) και εξετάζει αν το range από records πάνω στο οποίο θέλει να δουλέψει αν πέφτει σε κάποια
		προβληματική περίπτωση και έπειτα, αφήνει το mutex. Ο έλεγχος αυτός θα αναλυθεί ευθύς αμέσως. Αν δεν μπορεί, και
		υπάρχει έστω και μια προβληματική περίπτωση σαν αυτές που ειπώθηκαν πιο πάνω, τότε η διεργασία βάζει τον εαυτό της
		για ύπνο κάνοντας P signal στο δικό της semaphore πεδίο waiting_sem του proc_info. Αν μπορεί να εργαστεί στο
		επιθυμητό του range, ο worker προχωρά κανονικά στην επεξεργασία/ανάγνωση των records που βρίσκονται μέσα στο
		range του (wanted_range πεδίο).  Η διαδικασία αυτή που σε γενικές γραμμές περιγράφηκε από την στιγμή που η
		διεργασία πάρει το mutex, το αφήσει και ελέγξει αν πρέπει να μπλοκάρει τον εαυτό της ή όχι είναι η συνάρτηση:
		check_range_and_lock() του synchroUtils module.
		> Όταν τελειώσει την δουλειά του ένας worker τότε, παίρνει το mutex και εξετάζει πάλι τον πίνακα από proc_info
		(προφανώς τις θέσεις που είναι inhabited εκτός από την δική του) και ελέγχει αν με κάποιον από τους workers που
		είναι μπλοκαρισμένοι και κοιμούνται στους semaphores τους, αν μπορεί να τους ξυπνήσει. Δηλαδή, εξετάζει αν το
		range πάνω στο οποίο δούλεψε, το περιμένουν κάποια processes που ήρθαν μετά από αυτόν. Αυτή η διαδικασία θα
		εξηγηθεί ακόμη καλύτερα παρακάτω. Αφού ξυπνήσει αυτά τα συγκεκριμένα processes, αφήνει το mutex και προχωρά στον
		τερματισμό της. Η διαδικασία αυτή που σε γενικές γραμμές περιγράφηκε από την στιγμή που η διεργασία πάρει το
		mutex, ελέγξει και ξυπνήσει (αν πρέπει να ξυπνήσει) κάποια ή κάποιες άλλες διεργασίες ή όχι και αφήσει το mutex
		είναι η συνάρτηση: check_range_and_unlock() του synchroUtils module.

	* Προβληματικές περιπτώσεις - Range Conflicts
		> Στην υλοποίηση αυτή, όπως ίσως έχει ήδη γίνει αντιληπτό, έχει γίνει μια μικρή τροποποίηση/relaxation στις
		προβληματικές περιπτώσεις i-iii) που περιγράφηκαν στην αρχή αυτής της ενότητας.
		> Συγκεκριμένα, όπως -περίπου- και στην μια από τις deadlock-free λύσεις στο Dining Philosophers Problem όπου η
		κάθε φιλόσοφος κοιτά πρώτα αν και τα δύο chopsticks είναι διαθέσιμα αλλιώς δεν δεσμεύει κανένα, έτσι και στο
		συγκεκριμένο Readers-Writers Problem, μια διεργασία κοιτά ολόκληρο το range που θέλει να δεσμεύσει, αν είναι
		διαθέσιμο, οπότε και οι i-iii) μετασχηματίζονται σε:
			α) Ένας writer θέλει να ενημερώσει μια εγγραφή την οποία θέλουν να διαβάσουν ένας ή και περισσότεροι readers,
			δηλαδή περιέχεται στο range ενός ή και περισσότερων readers που έχουν εισαχθεί στο σύστημα.
			β) Ένας writer θέλει να ενημέρωσει μια εγγραφή την οποία θέλει να ενημερώσει κάποιος(-οι) άλλος(-οι) writer(s). 
			γ) Ένας reader θέλει να διαβάσει ένα range από εγγραφές, στο οποίο υπάρχει τουλάχιστον μια εγγραφή την οποία
			θέλει να ενημερώσει κάποιος(-οι) writer(s).

	* Προβληματικές περιπτώσεις - Ticket mechanism και blocked_by counter
		> Προφανώς, αν τα πράγματα τα αφήναμε ως έχουν, μια τέτοια υλοποίηση εύκολα θα οδηγούσε σε starvation από μικρό αριθμό
		από worker processes. Επιπλέον, δεν εξετάζουμε στις διεργασίες με τις οποίες παρουσιάζεται conflict, αν αυτές εργάζονται
		ή είναι μπλοκαρισμένες. Εδώ αρχίζουν και μπαίνουν στο παιχνίδι το priority και το blocked_by counter της εκάστοτε διεργασίας.
		> Όταν κατά το check_range_and_lock(), εντοπιστεί μια από τις προβληματικές περιπτώσεις α-γ), τότε αυξάνεται ο blocked_by
		counter της διεργασίας που καλεί την συνάρτηση και, αν στο τέλος ο counter αυτός είναι >0 τότε και μόνο τότε, η
		διεργασία βάζει τον εαυτό της για ύπνο.
		> Όμως, θα πρέπει να τηρήσουμε με κάποιον τρόπο και μια FCFS σειρά για τα worker processes (solve starvation). Για αυτό
		τον λόγο, διατηρούμε αυτή την global FIFO σειρά μέσω του ticket mechanism. Όταν, λοιπόν, κατά το check_range_and_lock(),
		παρουσιαστεί μια από τις προβληματικές περιπτώσεις α-γ), τότε εξετάζεται κιόλας αν η διεργασία που κάλεσε την συνάρτηση,
		είναι "γηραιότερη" από την διεργασία με την οποία παρουσιάζει conflict κοιτώντας τα priority των δύο διεργασιών.
		Στην περίπτωση αυτή, ΔΕΝ αυξάνεται ο blocked_by counter της πρώτης, ενώ, στην αντίθετη περίπτωση, αυξάνεται. Ο λόγος
		που εφαρμόζεται αυτή η λογική, είναι για να φροντίσουμε να μην μπλοκαριστεί μια διεργασία εργάτης Α, εξαιτίας κάποιας
		προβληματικής (ως προς την Α) διεργασίας Β που έχει φτάσει μετέπειτα από την Α, καθώς θα πρέπει η Α να είναι αυτή
		που θα πρέπει να εργαστεί πρώτη.
		> Ομοίως, κατά την check_range_and_unlock, αν η διεργασία A που αποχωρεί εντοπίσει κάποιο range conflict με τις διεργασίες
		που την περιμένουν Β_i, τότε, αν οι διεργασίες Β_i είναι "νεότερες" από την Α, η Α τους μειώνει τον blocked_by counter κατά
		1, αλλιώς δεν κάνει τίποτα. Αν ο blocked_by counter μιας B_i, μετά την μείωση, πάρει την τιμή 0, τότε η Α ξυπνά την Β_i,
		καθώς η τελευταία ουσιαστικά περίμενε μόνο την Α να αφήσει το range για να μπορέσει να δουλέψει.

	* Τελικά, οι α-γ) μετασχηματίζονται σε:
		1) Ένας writer θέλει να ενημερώσει μια εγγραφή την οποία διαβάζουν ή περιμένουν ήδη, ένας ή και περισσότεροι -γηραιότεροι
		από τον writer- readers. Δηλαδή, οι readers εργάζονται ή περιμένουν για ένα σύνολο που περιέχει την επιθυμητή εγγραφή του writer
		και αυτοί έχουν μεγαλύτερο priority από τον writer.
		2) Ένας writer θέλει να ενημέρωσει μια εγγραφή την οποία ενημερώνει ήδη κάποιος άλλος writer ή περιμένει ήδη κάποιος(-οι)
		άλλος(-οι) -γηραιότερος(-οι) από τον πρώτο- writer(s).
		3) Ένας reader θέλει να διαβάσει ένα range από εγγραφές, στο οποίο υπάρχει τουλάχιστον μια εγγραφή την οποία ενημερώνει ήδη 
		κάποιος γηραιότερος writer ή/και περιμένει να ενημερώσει κάποιος ή κάποιοι writers επίσης γηραιότεροι από τον reader (με
		μεγαλύτερο priority).

	* Μόλις εμφανιστεί μια από τις παραπάνω τρεις περιπτώσεις, η διεργασία αυξάνει τον blocked_by μετρητή της κατά 1. Στο τέλος, όταν
	έχει εξετασθεί όλος ο πίνακας των processes που βρίσκονται στο σύστημα, τότε η διεργασία βάζει τον εαυτό της για ύπνο.

	* Με παρόμοιο, αλλά αντίστροφο τρόπο γίνεται και το ξύπνημα των διεργασιών. Για λόγους που εύκολα μπορούν να γίνουν αντιληπτοί, η
	εξήγηση αυτού παραλείπεται.

Ε) Αιτιολόγηση ορθότητας λύσης στο πρόβλημα του Critical Section

	* Η αιτιολόγηση σε αυτό το section θα είναι σύντομη, καθώς το μεγαλύτερο κομμάτι της έχει καλυφθεί ήδη από την αμέσως προηγούμενη
	ενότητα.

--> Για κάθε worker process (αναγνώστης ή συγγραφέας), θεωρούμε ως:
	* Entry Section την check_range_and_lock()
	* Critical Section το block κώδικα ανάμεσα των check_range_and_lock() και check_range_and_unlock(). Συγκεκριμένα, αυτό το
	block παίρνει την σημασία του critical (όπως έχει οριστεί και στο μάθημα) όταν παρουσιάζεται μια προβληματική περίπτωση
	συγχρονισμού από αυτές που περιγράψαμε στο τέλος της ενότητας Δ). Υπενθυμίζουμε ότι το shared resource είναι κάθε record
	ξεχωριστά και όχι ολόκληρο το αρχείο. Υπό αυτή την έννοια, το section δεν είναι ακριβώς critical στατικά, καθόλη την διάρκεια
	εκτέλεσης του προγράμματος, αλλά, μπορεί να γίνει, δυναμικά, αν πέσουμε σε κάποια προβληματική περίπτωση συγχρονισμού.
	* Exit Section την check_range_and_unlock()
	* Ενώ, Remainder Section είναι όλο το υπόλοιπο κομμάτι κώδικα (π.χ. αρχικοποίηση command line arguments, opening shared memory
	segment, cleanup κτλπ...).

--> Mutual exclusion:
	Με το handling που περιγράφηκε στην προηγούμενη ενότητα [check_range_and_lock() και check_range_and_unlock()] εξασφαλίζεται ότι,
	κανένας writer δεν θα προσπαθήσει να γράψει σε μια εγγραφή που ήδη διαβάζει κάποιος reader(s) ή ενημερώνει κάποιος άλλος writer
	και κανένας reader δεν θα προσπαθήσει να διαβάσει ένα εύρος εγγραφών όπου υπάρχει έστω και μια εγγραφή την οποία ενημερώνει
	κάποιος writer.

--> Progress:
	Στην περίπτωση που δεν υπάρχει καμία διεργασία στο critical section -όπως αυτό ορίστηκε πιο πάνω- και κάποιες διεργασίες θέλουν
	να μπουν σε αυτό, τότε μόνο οι διεργασίες που δεν εκτελούν στο remainder section μπορούν να συμμετάσχουν στην απόφαση για το ποιά
	διεργασία θα πάρει τον έλεγχο του range μετά (θα μπει στο critical section) και η απόφαση αυτή δεν αναβάλλεται συνεχώς. Για να
	φέρουμε τον ορισμό αυτό πιο κοντά στην δική μας υλοποίηση και να γίνει αντιληπτό στον αναγνώστη γιατί ισχύει, σκεφτόμαστε ως εξής:
	
		* "...κάποιες διεργασίες θέλουν να μπουν σε αυτό..." (critical section)
			Εδώ εννοούμε ότι παρουσιάζεται ένα προβληματικό σενάριο συγχρονισμού λόγω conflicting ranges.

		* "...μόνο οι διεργασίες που δεν εκτελούν στο remainder section μπορούν να συμμετάσχουν...έλεγχο του range μετά"
			Αυτό επαληθεύται με το handling που κάνουμε, αφού οι διεργασίες οι ίδιες σέβονται τις προτεραιότητες και βάζουν τους
			εαυτούς για ύπνο στο entry section και ξυπνάνε άλλες διεργασίες όταν πρέπει στο exit section, συμμετέχοντας, έτσι και 
			μόνο έτσι (δηλαδή σε αυτά τα sections μόνο και με αυτούς τους τρόπους μόνο), ενεργά στην απόφαση για το ποιά διεργασία 
			θα πάρει τον έλεγχο, χωρίς να είναι στο remainder section τους.

		* "...η απόφαση αυτή δεν αναβάλλεται συνεχώς..."
			Προφανώς, η απόφαση αυτή δεν γίνεται να αναβάλλεται συνεχώς, αφού κατά το check_range_and_unlock(), ακολουθείται ένας
			FIFO-like μηχανισμός για τις διεργασίες που έχουν βάλει τους εαυτούς τους για ύπνο και περιμένουν να τις ξυπνήσουν για
			να μπουν στο critical section τους.

--> Bounded Waiting:
	Όπως περιγράψαμε παραπάνω, με το μηχανισμό προτεραιότητας και τον μετρητή blocked_by, εξασφαλίζεται ότι κανένα από τα processes
	δεν θα αδικηθεί ως προς την σειρά του ΑΝ δηλαδή προκύψει κάποια περίπτωση από τις 1-3). Οπότε, μόλις τελειώσουν την δουλειά τους
	οι workers τους οποίους περιμένει το process (πλήθους blocked_by), τότε θα δοθεί σε	αυτό πρώτα ο έλεγχος, δηλαδή το επιθυμητό του
	range.

ΣΤ) Τεχνικές λεπτομέρειες

--> Οι περισσότερες τεχνικές λεπτομέρειες έχουν καλυφθεί από τις αμέσως προηγούμενες δύο ενότητες. Παρόλ'αυτά, μερικές λεπτομέρειες
	άξιας σημασίας, είναι:
	
		* Στον accountant έχει εφαρμοστεί η τεχνική του handshake για τον συγχρονισμό του με τις διεργασίες που τον ξυπνάνε.
		* Μπορούμε να υπολογίσουμε ακριβώς το πλήθος των logs που θα γίνουν από τον accountant, καθώς ένα log γίνεται κάθε
		φορά που μια διεργασία μπαίνει ή βγαίνει από το σύστημα. Δηλαδή: 

				#(logs) = 2*n_children 
		
			όπου n_children το -n flag στον initializer
		
		* Η ενημέρωση τον στατιστικών και το ξύπνημα του accountant γίνεται στις συναρτήσεις stats_entry() και stats_exit()
		του synchroUtils.c (εσωτερικές).
		* Ο έλεγχος του concurrent process array κατά την είσοδο και κατά την έξοδο μια διεργασίας worker (έλεγχος των
		περιπτώσεων 1-3 ενότητας Δ) γίνεται στις συναρτήσεις check_range_entry() και check_range_exit() του synchroUtils.c
		(εσωτερικές).
		