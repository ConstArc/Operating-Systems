Α.Μ: sdi2100008
Ο/Ε: Κωνσταντίνος Αρκουλής

Η εργασία αυτή αφορά την 2η εργασία του μαθήματος:

		Κ22 Λειτουργικά Συστήματα της σχολής Πληροφορικής και Τηλεπικοινωνιών ΕΚΠΑ
	Ακαδημαϊκό έτος 2023-2024, χειμερινό εξάμηνο -τμήμα Αρτίων. Διδάσκων: κ. Αλέξης Δελής

							!!! ΣΗΜΕΙΩΣΗ !!!
	Η συγγραφή του συγκεκριμένου Readme.txt, έγινε μέσα από το VSCODE IDE.
	Επομένως, για προβλήματα στην μορφοποίηση/στοίχιση του κειμένου, προτείνεται
	η ανάγνωση μέσα από το ίδιο IDE (κατά προτίμηση σε fullscreen)

Περιεχόμενα:
	Α) Εκτέλεση προγράμματος και Makefile  					γραμμή 21
	Β) Περιγραφή αρχιτεκτονικής κώδικα 	   				 	γραμμή 60
	Γ) Σημεία ιδιαίτερης σημασίας, τεχνικές λεπτομέρειες 	γραμμή 129
	Δ) Πολυπλοκότητες των αλγορίθμων ταξινόμησης			γραμμή 188
	Ε) Παραδοχές 						   					γραμμή 211

Α) Εκτέλεση προγράμματος και Makefile

--> Προϋποθέτουμε ότι ο χρήστης είναι στο parental folder της εργασίας, δηλαδή στο ίδιο folder που βρίσκεται και το Makefile.

--> Το Makefile έχει φτιαχτεί με τέτοιο τρόπο ώστε να κάνει separate compilation (όπως ζητείται εξάλλου και από την εκφώνηση). 
	Για την δημιουργία του, έχω συμβουλευτεί διάφορες πηγές στο διαδίκτυο, με ίσως την πιο σημαντική να είναι η: 
		https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/

--> Το folder structuring έχεις ως εξής:
	* output:  μετά το compilation του κώδικα, τοποθετούνται όλα τα αντικειμενικά αρχεία (.o) και τα εκτελέσιμα αρχεία.
	* include: εδώ περιέχονται όλα τα header (.h) αρχεία του κώδικα
	* src: 	   τα αρχεία πηγαίου κώδικα (.src)
	* logs:	   δημιουργείται και τοποθετείται το αρχείο Logs.txt που εξηγείται παρακάτω.
	* valout:  δημιουργούνται και τοποθετούνται τα αρχεία "[PID].log" που περιέχουν το log του εργαλείου valgrind για το
	συγκεκριμένο process, αν επιλεχθεί η εκτέλεση με valgrind για έλεγχο για memory leaks (λεπτομέρειες παρακάτω).
	* tests:   εδώ πέρα βρίσκονται τα παραδείγματα που συνοδεύουν την εργασία, μαζί με τα υπόλοιπα αρχεία Verify.c καθώς
	και ένα επιπλέον voters5.bin για τον έλεγχο ότι το πρόγραμμα λειτουργεί σωστά ακόμα και με processes που αναλαμβάνουν
	να ταξινομήσουν 0 records.

--> Η αλλαγή του testfile που θα δοθεί στο πρόγραμμα για ταξινόμηση καθώς και των υπολοίπων αρχικών παραμέτρων
	(-k, -e1, -e2 flag), γίνεται στο Makefile.

--> Το αρχείο Logs.txt που δημιουργείται στην εκτέλεση του προγράμματος περιέχει logs και πιθανώς (ελπίζουμε πως όχι) errors
	που γίνονται triggered από τις διάφορες διεργασίες. Τέτοια logs/errors μπορεί να είναι πχ της μορφής LOG_FORK που ενημερώνει
	για την σωστή εκτέλεση της fork() system call. Όλο το κομμάτι του logging το αναλαμβάνει το module logs.c - logs.h. Για αυτούς
	τους logging σκοπούς, χρησιμοποιείται το #define FILE_CODE στην αρχή του κάθε process.c αρχείο. Περισσότερα στον κώδικα.

--> Για απλή εκτέλεση χωρίς έλεγχο για memory leaks:
	$ make run

--> Για εκτέλεση με έλεγχο για memory leaks:
	$ make valgrind

--> Για καθαρισμό των αρχείων στο output:
	$ make clean

--> Είτε μέσω της εκτέλεσης make run είτε μέσω της εκτέλεσης make valgrind, πρώτα, γίνεται ένα make clean εσωτερικά από τα
	ίδια αυτά rules.

Β) Περιγραφή αρχιτεκτονικής κώδικα

--> processUtils module (processUtils.c - processUtils.h)
	* Είναι το module που περιέχει κοινές συναρτήσεις που χρησιμοποίουνται στα διάφορα processes. Για παράδειγμα, η RunSplitter()
	είναι η συνάρτηση που χρησιμοποιείται κατά το splitting phase τόσο του coordinator όσο και του workloader (επεξήγηση αυτών
	των διεργασιών ακριβώς από κάτω). Άλλες συναρτήσεις που περιέχει το συγκεκριμένο module είναι η pipes_init() και η
	pipes_destroy() που η πρώτη αρχικοποιεί έναν πίνακα από δισδιάστατους πίνακες (pipes) και η δεύτερη τον καταστρέφει και
	απελευθερώνει τον χώρο που δεσμεύτηκε. Περισσότερες λεπτομέρειες στον κώδικα.

--> coordinator process (coordinator.c)
	* Όπως και στο process tree που δίνεται στην εκφώνηση, ο coordinator είναι η διεργασία ρίζα που γίνεται spawned στην 
	εκτέλεση του προγράμματος από τον χρήστη.
	* Ευθύνη του coordinator είναι η δημιουργία των processes του επόμενου layer (workloaders) στο process tree, μαζί με
	τα bounds των records (start, capacity) που θα ταξινομήσουν οι workloaders έμμεσα (splitting phase). Αυτή η διαδικασία
	γίνεται επαναληπτικά για NumofChildren φορές και κάθε φορά ενημερώνονται κατάλληλα το start (record index από όπου ξεκινά 
	το sorting) και το capacity (αριθμός από records για ταξινόμηση) μέσω της συνάρτησης set_child_record_bounds() του
	processUtils module.
	* Ο coordinator, στο merging phase, καλεί την συνάρτηση RunMerger του processUtils.h η οποία:
		> Παίρνει τα αποτελέσματα από τους workloaders μέσω του αντίστοιχου pipe.
		> Όταν λάβει όλα τα αποτελέσματα από όλους τους workloaders του, τότε τα κάνει merge μέσω της σύναρτησης merge_results() 
		του processUtils.h, για την διαμόρφωση του τελικού αποτελέσματος.
	* Έπειτα ο coordinator εκτυπώνει στο tty το τελικό αποτέλεσμα. Επιπλέον, εκτυπώνει τα CPU, REAL time measurements του κάθε 
	sorter.
	* Τέλος, άλλο ένα feature του coordinator είναι να πιάνει τα σήματα SIGUSR1, SIGUSR2 που αποστέλλουν οι workloaders, sorters 
	αντίστοιχα και -ενημερώνοντας κατάλληλα τις global μεταβλητές workloader_sig, sorter_sig σε κάθε catch-, εκτυπώνει στο τέλος 
	τον τελικό αριθμό από SIGUSR1, SIGUSR2 signals που έλαβε. Προσοχή: οι παραπάνω μετρήσεις (number of SIGUSR1, SIGUSR2 signals 
	received) είναι unreliable αφού πολλαπλά ίδια signals γίνονται discarded από το λειτουργικό. Επομένως τα νούμερα αυτά στο 
	αποτέλεσμα είναι πάντα <= από τα πραγματικά νούμερα.

--> workloader process (workloader.c)
	* Είναι το δεύτερο layer στο process tree που καλούμαστε να υλοποιήσουμε και στην ούσια διαδραματίζει τον ρόλο του 
	splitter-merger.
	* Κατά το splitting phase, ο workloader δημιουργεί επαναληπτικά τα sorter processes και τους αναθέτει τα bounds των records 
	(start, capacity) που θα ταξινομήσουν το καθένα, μέσω της συνάρτησης set_child_record_bounds().
	* Στο merging phase (RunMerger), ο workloader παίρνει τα αποτελέσματα από τους sorters μέσω του αντίστοιχου pipe. Όταν λάβει 
	όλα τα αποτελέσματα από όλους τους sorters του, τότε τα κάνει merge μέσω της σύναρτησης merge_results() και δίνει το τελικό 
	αποτέλεσμα του στην ρίζα, γράφοντας (write) στο STDOUT. Επιπλέον, περνάει τα CPU, REAL time measurements του κάθε sorter στον 
	coordinator.
	* Λίγο πριν το τέλος της εκτέλεσης του, ένας workloader αποστέλλει το σήμα SIGUSR1 στον coordinator, ενημερώνοντας έτσι
	ο πρώτος τον δεύτερο για την σωστή διεξαγωγή της εκτέλεσης του.

--> heapsort process (heapsort.c)
	* Είναι ο ένας από τους δύο sorters που έχουν υλοποιηθεί στα πλαίσια αυτής της εργασίας.
	* Όπως εύκολα μπορεί να διαπιστωθεί ο συγκεκριμένος sorter αξιοποιεί τον αλγόριθμο Ταξινόμησης Σωρού για την ταξινόμηση των
	εγγραφών. Για την συγγραφή του κώδικα αυτού του αλγορίθμου, έχουν χρησιμοποιηθεί συμβουλευτικά οι ψευδοκώδικες που παρέχει
	το βιβλίο: "Εισαγωγή στους Αλγορίθμους CLRS 3η έκδοση" στις σελίδες 152, 155, 158. Σε αυτές τις σελίδες βρίσκονται αντίστοιχα
	οι αλγόριθμοι σε ψευδογλώσσα: "Αποκατάσταση Σωρού Μεγίστου", "Κατασκευή Σωρού Μεγίστου", "Ταξινόμηση Σωρού" που
	χρησιμοποιούνται αντίστοιχα στις συναρτήσεις: heapify, στο πρώτο μισό της heap_sort, στο δεύτερο μισό της heap_sort.
	Περισσότερες λεπτομέρειες υλοποίησης στον κώδικα.
	* Μαζί με τον mergesort-sorter, συντελούν το τρίτο και τελευταίο layer στο process tree που καλούμαστε να υλοποιήσουμε και 
	στην ούσια διαδραματίζει τον ρόλο του sorter που θα ταξινομήσει εν τέλει 'capacity' αριθμό εγγραφών, ξεκινώντας από το 
	'start' του αρχείου.
	* Στο τέλος, αποστέλλεται το τελικό αποτέλεσμα της ταξινόμησης μέσω (simple) pipe στην διεργασία γονέας, δηλαδή στον
	workloader, γράφοντας (write) στο STDOUT. Επιπλέον γράφονται στο STDOUT και τα CPU, REAL time measurements που αφορούν
	ολόκληρο τον χρόνο εκτέλεσης (real και cpu) του sorter.
	* Τέλος, λίγο πριν το τέλος της εκτέλεσης του, ένας sorter αποστέλλει το σήμα SIGUSR2 στον coordinator, ενημερώνοντας έτσι 
	ο πρώτος τον δεύτερο για την σωστή διεξαγωγή της εκτέλεσης του.

--> mergesort process (mergesort.c)
	* Είναι ο δεύτερος sorter από τους δύο που έχουν υλοποιηθεί στα πλαίσια αυτής της εργασίας. 
	* Όπως εύκολα μπορεί να διαπιστωθεί ο συγκεκριμένος sorter αξιοποιεί τον αλγόριθμο mergesort για την ταξινόμηση των εγγραφών. 
	Ακολουθεί την top-down προσέγγιση όπως αυτή διατυπώνεται στο wikipedia: https://en.wikipedia.org/wiki/Merge_sort και επιπλέον
	έχουν χρησιμοποιηθεί συμβολευτικά οι ψευδοκώδικες που παρέχει το βιβλίο: "Εισαγωγή στους Αλγορίθμους CLRS 3η έκδοση" στις
	σελίδες 33, 35. Σε αυτές τις σελίδες βρίσκονται αντίστοιχα οι αλγόριθμοι σε ψευδογλώσσα: "Συγχώνευση",
	"Συγχωνευτική Ταξινόμηση"  που χρησιμοποίουνται αντίστοιχα στις συναρτήσεις merge() και merge_sort() με μερικές τροποποιήσεις,
	κυρίως στην πρώτη.
	* Επί της ουσίας, ισχύουν τα ίδια υπόλοιπα points (από το 3 και μετά) με αυτά του heapsort-sorter.


Γ) Σημεία ιδιαίτερης σημασίας, τεχνικές λεπτομέρειες

--> IPC
	> Για την επικοινωνία μεταξύ των processes, έχουν χρησιμοποιηθεί απλά pipes, για την αποστολή των ταξινομημένων αποτελεσμάτων
	από τα χαμηλότερα layers στα υψηλότερα layers του process tree της εκφώνησης καθώς και για την αποστολή των time measurements
	των sorters προς την ρίζα, για την τελική τους εκτύπωση στο tty. Ο μηχανισμός είναι απλός:
		i)   Στο parent process δεσμεύουμε τον χώρο για τα pipes που θα χρησιμοποιηθούν για την επικοινωνία με τα child processes
		Μετά το fork(), για κάθε παιδί (child_i) που δημιουργείται:
		ii)  Στο parent process κλείνουμε το write end του αντίστοιχου set από pipes (parent - child_i)
		iii) Στο child process, πριν την κλήση της execl(), κλείνουμε το read end του pipe, κάνουμε
		dup2() το write end του pipe με το standard output (για να κάνει αργότερα το child process write σε αυτό το fd τα 
		αποτελέσματα του) και, τέλος, κλείνουμε το αρχικό write end του pipe αφού τώρα είναι πια duplicated (για να αποφευχθούν 
		τυχόν resource leaks).
	> Τα close() παραπάνω γίνονται για να διασφαλίσουμε ότι η διεργασία γονέας δεν θα γράψει στο pipe όσο θα γράφει η διεργασία
	παιδί τα αποτελέσματα της και η διεργασία παιδί δεν θα διαβάσει κάτι από το pipe, έτσι ώστε να λάβουμε σωστά αποτελέσματα.
	> To βήμα iii) υλοποιείται μέσω της συνάρτησης prepare_pipe() του processUtils.h.
	> Η παραπάνω διαδικασία (βήματα i, ii, iii) γίνεται σχεδόν ολόιδια και για τον coordinator με τα παιδιά του (workloaders)
	και για κάθε έναν workloader με τα παιδιά του (sorters).
	> Επιπλέον, έχουν χρησιμοποιηθεί signals για το αντίστοιχο ζητούμενο της εκφώνησης, χρησιμοποιώντας kill() και signal()
	system calls, με το δεύτερο να αναλαμβάνει το overwrite των μεθόδων που θα διαχειριστούν τα σήματα SIGUSR1, SIGUSR2 στον 
	coordinator, μέσω των συναρτήσεων succesful_workloader_exit(), succesful_sorter_exit() αντίστοιχα. Όμως, όπως περιγράφηκε και
	παραπάνω, το signaling εδώ είναι unreliable.
	> Από την οικογένεια των exec* συναρτήσεων επιλέχθηκε η execl() καθώς η απλότητα/λιτότητα της ταιριάζει αρκετά στους σκοπούς
	αυτής της εργασίας.

--> Functions
	> void Read(int fd, void* dest, size_t n_bytes, int file_code)
		* Είναι μια wrapper function για το read() syscall.
		* Διαβάζει επαναληπτικά bytes από το fd στο dest μέχρι να έχουν διαβαστεί όλα τα n_bytes.
		* Περισσότερα στον κώδικα.

	> record* merge_results(record** records_array, int* capacities_array, int n_children, int file_code)
		* Κάνει merge n_children ταξινομημένων πινάκων διαφορετικών μεγεθών.
		* Αν i είναι ο i-οστος ταξινομημένος πίνακας της εισόδου, το μέγεθους του σε εγγραφές είναι το capacities_array[i].
		* Η συγχώνευση γίνεται ανά δύο μέσω της merge_pair η οποία είναι μια απλή συνάρτηση συγχώνευσης δύο ταξινομημένων
		πινάκων. Ο τρόπος που λειτουργεί είναι να διασχίζει και τους δύο πίνακες ταυτόχρονα μέχρι να τελειώσει την διάσχιση
		του ένας από τους δύο. Κατά την διάσχιση συμπληρώνεται ο πίνακας αποτέλεσμα διαλέγοντας το μικρότερο record την φορά
		εκ των δύο και μετά την διάσχιση απλά συμπληρώνονται με την ίδια σειρά οι υπόλοιπες εγγραφές του άλλου πίνακα, στον
		πίνακα αποτέλεσμα.
		* Στο τέλος, επιστρέφεται το τελικό sorted array από records
		* Περισσότερα στον κώδικα.
		
--> Γενικά
	> Για τον υπολογισμό των χρονομετρήσεων στους sorters, έχει χρησιμοποιηθεί ο κώδικας του Παραρτήματος 1, που συνοδεύει
	την εκφώνηση της εργασίας.
	> Για διευκόλυνση κατά την διαχείριση των αποτελεσμάτων των child processes, χρησιμοποιείται το struct child_args (που
	βρίσκεται στο processUtils.h) τόσο για τα παιδιά του coordinator (workloaders) όσο και για τα παιδιά ενός workloader
	(sorters).
	> Για τον τρόπο που ελέγχονται και αποθηκεύονται τα command line arguments στον coordinator, έχουν χρησιμοποιηθεί συναρτήσεις
	εισόδου που χρησιμοποιήθηκαν και στην προηγούμενη εργασία του μαθήματος για τους ίδιους σκοπούς, ελαφρά τροποποιημένες
	(inputUtils.c inputUtils.h).
	> Το άνοιγμα του δοθέντος αρχείου γίνεται:
		* Μια φορά στην αρχή της διεργασίας coordinator για την μέτρηση των εγγραφών του αρχείου
		* Σε κάθε sorter διεργασία για την ταξινόμηση των εγγραφών: records[start] μέχρι records[start + capacity].
		Επιπλέον, μετά το άνοιγμα του αρχείου και πριν την ταξινόμηση, χρησιμοποιείται η lseek() για να μετακινηθεί ο fd στο
		start που έχει ήδη προσδιορίσει ο workloader για τον συγκεκριμένο sorter.
		Η επιλογή να γίνεται το άνοιγμα του αρχείου στους sorters έγινε για να αποφευχθεί τυχόν race condition στους file 
		descriptors, που θα μπορούσε να πραγματοποιηθεί αν γινόταν το άνοιγμα μόνο στον coordinator.

Δ) Πολυπλοκότητες των sorting algorithms που έχουν επιλεχθεί
Σε αυτό το section θα γίνει μια σύντομη αναφορά (καθώς δεν είναι αυτός ο σκοπός της συγκεκριμένης εργασίας) των 
πολυπλοκοτήτων χρόνου και χώρου των δύο αλγορίθμων ταξινόμησης που έχουν υλοποιηθεί.

--> mergesort
	* Worst, average, best-case time complexity: O(nlogn),
		όπου n το πλήθος των έγγραφων που έχουν δοθεί προς ταξινόμηση στον συγκεκριμένο sorter (capacity)
	Η αιτιολόγηση προκύπτει από το recurrence relation του αλγορίθμου ταξινόμησης με συγχώνευση:

					T(n) = 2T(n/2) + n
	
	* Space complexity: O(n),
		όπου n το πλήθος των έγγραφων που έχουν δοθεί προς ταξινόμηση στον συγκεκριμένο sorter (capacity)
	Η αιτιολόγηση είναι απλή αφού φτιάχνεται συνολικά ένας προσωρινός πίνακας μεγέθους n κατά την διάρκεια
	της merge για την αποθήκευση των επιμέρους ταξινομήσεων.

--> heapsort
	* Worst, average, best-case time complexity: O(nlogn),
		όπου n το πλήθος των έγγραφων που έχουν δοθεί προς ταξινόμηση στον συγκεκριμένο sorter (capacity)
	* Space complexity: O(1)
	Αφού δεν χρησιμοποιείται επιπλέον χώρος πέραν από αυτόν της εισόδου.


Ε) Παραδοχές

--> Η επιλογή του αλγόριθμου ταξινόμησης στο επίπεδο των sorters γίνεται εναλλάξ μεταξύ των παιδιών ενός συγκεκριμένου
	workloader. Δηλαδή:
		Για το πρώτο παιδί ενός workloader, έστω sorter_0, αυτό θα έχει τον αλγόριθμο ταξινόμησης e1 όπως αυτός
	έχει δοθεί από την γραμμή εντολών κατά την εκτέλεση του mysort. Έπειτα το sorter_1 το e2, το sorter_2 το e1 πάλι και
	συνεχίζει έτσι (εναλλάξ).

--> Σε περίπτωση που η διαίρεση n_records / NumofChildren στον coordinator, αφήνει κάποιο υπόλοιπο, τότε, αυτές οι εγγραφές
	που περισσεύουν θα ταξινομηθούν στον τελευταίο workloader (index = NumofChildren - 1).

--> Αν και γίνεται ένας αρχικός έλεγχος του πλήθους των παραμέτρων που περνά ο χρήστης στην εκτέλεση του mysort (καθώς και
	για το αν το argument -k είναι θετικός ακέραιος), είναι ευθύνη του χρήστη να περάσει σωστά τα arguments -e1, -e2, δηλαδή
	να περάσει είτε πρώτα το string "heapsort" και μετά το "mergesort" (-e1 heapsort -e2 mergesort) είτε ανάποδα 
	(-e2 heapsort -e1 mergesort), όχι, όμως, διαφορετικά strings.