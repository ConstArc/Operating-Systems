!!! ΣΗΜΕΙΩΣΗ: η συγγραφή του συγκεκριμένου Readme.txt, έγινε μέσα από το VSCODE IDE. 
	Επομένως για προβλήματα στην μορφοποίηση (indentation) του κειμένου, προτείνεται η 
	ανάγνωση μέσα από το ίδιο IDE (κατά προτίμηση σε fullscreen) !!!

Περιεχόμενα (sections):
	Α) Εκτέλεση προγράμματος και Makefile,  γραμμή 11
	Β) Περιγραφή αρχιτεκτονικής κώδικα, 	γραμμή 56
	Γ) Επεξήγηση πολυπλοκοτήτας, 			γραμμή 194
	Δ) Παραδοχές,							γραμμή 237

Α) Εκτέλεση προγράμματος και Makefile

--> Προϋποθέτουμε ότι ο χρήστης είναι στο parental folder της εργασίας, δηλαδή στο ίδιο folder που βρίσκεται και το Makefile.

--> Το Makefile έχει φτιαχτεί με τέτοιο τρόπο ώστε να κάνει separate compilation (όπως ζητείται εξάλλου και από την εκφώνηση). Για την
	δημιουργία του, έχω συμβουλευτεί διάφορες πηγές στο διαδίκτυο, με ίσως την πιο σημαντική να είναι η: 
		https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/

--> Πέραν των flags της εκφώνησης (-f, -b) έχει προστεθεί και ένα επιπλέον, το -m. Το όρισμα μετά από αυτό το flag είναι το initial size
	του hash table. Όλα τα flags (-f, -b, -m) είναι υποχρεωτικά να δοθούν και να αρχικοποιηθούν για την εκτέλεση του προγράμματος, αλλιώς
	το πρόγραμμα δεν θα εκτελεστεί και ένα σχετικό μήνυμα λάθους θα εμφανιστεί στο αρχείο Error.txt (περισσότερα για αυτό το αρχείο παρακάτω).

--> Το folder structuring έχεις ως εξής:
	* output:  μετά το compilation του κώδικα, τοποθετούνται όλα τα αντικειμενικά αρχεία (.o) και το εκτελέσιμο αρχείο (./mvote).
	* include: εδώ περιέχονται όλα τα header (.h) αρχεία του κώδικα
	* src: 	   τα αρχεία πηγαίου κώδικα (.src)
	* logs:	   δημιουργούνται και τοποθετούνται τα αρχεία Leaks.txt και Errors.txt που περιγράφονται λίγο παρακάτω.
	* tests:   κανονικά εδώ πέρα θα βρίσκονταν κατεβασμένα ήδη τα παραδείγματα που συνοδεύουν την εργασία, παρόλ' αυτά, έπειτα από σαφείς
	οδηγίες δεν έπρεπε το παραδοτέο να περιέχει tests, οπότε και σβήστηκαν. Για τυπικούς λόγους, έχω διατηρήσει το συγκεκριμένο directory
	ακόμη και κενό και ο χρήστης μπορεί για δική του οργάνωση να αποθηκεύει εκεί πέρα τα δικά του test.

-->	Στο parental folder της εργασίας, έχοντας πρώτα επιλέξει το test (voters50/500/5000.csv) και τις παραμέτρους -b, -m στο 
	Makefile, εκτελείτε τις ακόλουθες εντολές:
	
	1) Για απλή εκτέλεση:
		$ make
		$ make run

	2) Για εκτέλεση με έλεγχο για memory leaks:
		$ make valgrind
	
	3) Καθαρισμός των αρχείων μέσα στα ouput και logs directories:
		$ make clean

	* Και στις δύο περιπτώσεις (1 και 2), οποιοδήποτε output από errors που δεν σχετίζεται με τα errors του "Κανόνες Μορφοποίησης εξόδου 
	του προγράμματος" της εκφώνησης, μεταφέρεται από το ρεύμα stderr και γίνεται redirect σε ένα καινούργιο αρχείο στο logs directory, με 
	όνομα Errors.txt. Τέτοια errors μπορεί να είναι πχ κακή χρήση command line arguments κατά την εκτέλεση του προγράμματος, malloc/
	realloc failure και άλλα.
	* Στην περίπτωση που επιλεχθεί η εκτέλεση του προγράμματος με valgrind, τότε, δημιουργείται και το αρχείο Leaks.txt στο logs directory. 
	Εκεί, γράφεται όλο το output από το εργαλείο valgrind κατά την εκτέλεση και τον τερματισμό του προγράμματος. (Σημείωση: σε αυτή την επιλογή
	το valgrind δίνει ένα επιπλέον φόρτο και το initial file insertion με το μεγαλύτερο test file: voters100000.csv στην εκτέλεση του προγραμμάτος, 
	καθυστερεί περίπου 2-3 δευτερόλεπτα στα μηχανήματα της σχολής)
	* Σε κάθε περίπτωση, ο χρήστης μπορεί να τεστάρει τα δικά του αρχεία αρχικοποίησης του hash table καθώς και αρχεία για την εντολή bv, 
	αρκεί να έχουν το σωστό format (βλ. παραδοχές section Δ) και να δίνει το σωστό path κάθε φορά.

Β) Περιγραφή αρχιτεκτονικής κώδικα

--> Βοηθητικές δομές

	1) Συνδεδεμένη λίστα (LinkedList module)
		* Αποτελείται από το LinkedList.h (header) και LinkedList.c (source)
		* Χρησιμοποιούνται για μείωση της πολυπλοκότητας σε διάφορα operations (πχ list_append) δύο pointers, ένας στην αρχή της λίστας
		(head) και ένας στο τέλος της λίστας (tail).
		* Περιέχει όλα τα functionalities που παρέχει μια συνδεδεμένη λίστα, δηλαδή:
			i)   Εισαγωγή στοιχείου στο τέλος της λίστας (list_append). 	Πολυπλοκότητα O(1)
			ii)  Εξαγωγή στοιχείου από την αρχή της λίστας (list_remove). 	Πολυπλοκότητα O(1)
			iii) Αναζήτηση στοιχείου μέσα στην λίστα (list_search).			Πολυπλοκότητα Ο(n), όπου n το πλήθος των στοιχείων της λίστας
			iv)  Και άλλες βοηθητικές συναρτήσεις (περισσότερα στον κώδικα).
		* Είναι generic struct, οπότε μπορεί να λειτουργήσει με οποιοδήποτε item, κάνοντας χρήση void pointers.

	2) Utils module (utils.h, utils.c)
		* Περιέχει την συνάρτηση validArgs η οποία κάνει έναν πρώτο έλεγχο των command line arguments που δίνει ο χρήστης κατά την εκτέλεση
		του προγράμματος, και, αν τα arguments αυτά περάσουν όλους τους απαραίτητους ελέγχους, αρχικοποιούνται οι μεταβλητές:
			i)   file_name: το πλήρες path του αρχείου από το parental folder, με το οποίο αρχείο θα αρχικοποιήσουμε την βάση (-f flag).
			ii)  m:         το αρχικό μέγεθος του HashTable (-m flag).
			iii) b:         το μέγεθος των buckets του HashTable (-b flag).
		* Περιέχει ορισμένες συναρτήσεις οι οποίες απλά βοηθούν στην ομαλή ανάγνωση, εισαγωγή και στον έλεγχο, των εντολών που εισαγάγει ο
		χρήστης. Συγκεκριμένα, έχουμε τις συναρτήσεις:
			i)   validArgs:  περιγράφηκε παραπάνω
			ii)  trimInput:  αφαιρεί τον χαρακτήρα "\n" από τις εντολές του χρήστη
			iii) tokenCount: μετράει το πλήθος των λέξεων σε μια εντολή
			iv)  isPositiveIntegerNumber: ελέγχει αν ένα string είναι θετικός ακέραιος αριθμός
			v)   clearInput: καθαρίζει τον buffer (το input που δίνει ο χρήστης)

--> Βασικές δομές

	1) Ψηφοφόρος (Voter module) 
		* Voter.h (header) και Voter.c (source)
		* Παρέχει την δομή και όλα τα functionalities της οντότητας "ψηφοφόρου" που θα χρειαστούμε στην συγκεκριμένη εργασία, 
			δηλαδή:
			i)   Το struct της δομής αποτελείται από το όνομα, το επώνυμο, τον αριθμό μητρώου και 
					την κατάσταση του/της ψηφοφόφορου (αν έχει ψηφίσει ή όχι).
			ii)  Δημιουργία ψηφοφόφορου (voter_create).
			iii) Μαρκάρισμα ότι ο ψηφοφόρος ψήφισε (voter_vote).
			iv)  Μια απλή συνάρτηση εκτύπωσης των στοιχείων του ψηφοφόρου (voter_print).
			v) ...

	2) HashTable module (HashTable.h, HashTable.c) ή αλλιώς ο πίνακας κατακερματισμού της βάσης
		* Η δομή αυτή και οι απαιτούμενες λειτουργίες της, υλοποιήθηκαν με βάση το συνοδευόμενο paper αυτής της εργασίας (Linear Hashing: 
		Key Aspects and a Running Example Yannis Chronis and Alex Delis).
		* Το module αυτό υλοποιεί ένα hash table struct που κάνει χρήση γραμμικού κατακερματισμού. Παρέχει τις συναρτήσεις:
			i)   hash_table_create: δημιουργία του hash_table
			ii)  hash_table_insert: εισαγωγή στο hash_table, με τον ίδιο αλγόριθμο που περιγράφεται και στο παραπάνω paper
			iii) hash_table_search: εύρεση κλειδιού στο hash_table, πάλι με τον ίδιο αλγόριθμο του paper
			iv)  Και άλλες συναρτήσεις (περισσότερα στον κώδικα).
		* Το hash_function αυτής της δομής είναι ίδιο με αυτό του paper, δηλαδή:

				H = key mod (2^i) * m, όπου:

			i)   H το hash_function
			ii)  key η τιμή κλειδιού των εγγραφών της βάσης (Pin των ψηφοφόρων)
			iii) i το round που βρισκόμαστε κατά το συγκεκριμένο insertion/list_search
			iv)  m το αρχικό μέγεθος του hash_table 

	3) InvertedIndex module (InvertedIndex.h, InvertedIndex.c) ή αλλιώς ο ανεστραμμένος κατάλογος της βάσης
		* Η δομή αυτή υλοποιεί την δομή του ανεστραμμένου καταλόγου της εκφώνησης.
		* Η συγκεκριμένη υλοποίηση γίνεται με μια 2-διάστατη λίστα, όπου, έχοντας ως εικόνα το παράδειγμα της εκφώνησης:
			i)   Η οριζόντια λίστα είναι μια double-ended linked list που την κρατάμε sorted (σε φθίνουσα σειρά) με βάση το
			πλήθος των ψηφοφόρων σε αυτό των ταχυδρομικό κώδικα. Ο λόγος που την κρατάμε sorted είναι για καλύτερη πολυπλοκότητα
			στην εντολή o του χρήστη. 
			ii)  Οι κόμβοι της οριζόντιας λίστας είναι η δομή zipcode_node. Κάθε τέτοιος κόμβος πέρα από τους pointers next, back
			(για την δημιουργία του double-ended ll), περιέχει την λίστα με τους voters που έχουν ψηφίσει σε αυτό το Τ.Κ. (voters_list), 
			τον αριθμό αυτών των voters (n_voters), ή αλλιώς το μέγεθος αυτής της κάθετης λίστας και, εννοείται, τον ταχυδρομικό κώδικα 
			(postal_code) που με βάση αυτόν κάνουμε identify τους zipcode_nodes (είναι μοναδικός για κάθε zipcode_node).

	4) DataBase module (DataBase.c, DataBase.h)
		* Είναι η βασική δομή της βάσης που χρησιμοποιεί το πρόγραμμα.
		* Εμπεριέχει και κάνει έτσι encapsulate για τις ανάγκες του προγράμματος μας, μια δομή HashTable και μια δομή InvertedIndex.
		* Είναι ο διαμεσολαβητής μεταξύ του Command module και των παραπάνω module (HashTable, InvertedIndex). Η χρησιμότητα του είναι εμφανής
		στο κομμάτι του abstraction και στο γενικότερο code structure αυτής της εργασίας (για περισσότερα, στο interface του module: DataBase.h).

	5) Command module (Command.h, Command.c)
		* Είναι η διεπαφή ανάμεσα στην main και στο module της βάσης μας (DataBase), καθώς και ο χώρος ζωής της τελευταίας (πιο συγκεκριμένα ο
		χώρος ζωής της βάσης είναι μέσα στην συνάρτηση RunDB που προσφέρει το Command module και θα επισημάνουμε ευθύς αμέσεως).
		* Η μοναδική συνάρτηση που βλέπει και χρησιμοποιεί η main από αυτό το module είναι η RunDB, στην οποία δημιουργούμε
		την βάση και σε ένα loop της μορφής while(1), ζητάμε συνεχώς είσοδο από τον χρήστη για να επικοινωνεί ο τελευταίος 
		με την βάση. Το loop αυτό (και άρα και το πρόγραμμα) τερματίζει, όταν ο χρήστης δώσει την εντολή exit (όπου και εμφανίζονται
		τα bytes που αποδεσμεύονται εκείνη την στιγμή μέσω της global μεταβλητής bytes_freed) ή όταν συμβεί κάποιο EXIT_FAILURE.
		* Περιέχει όλα τα functionalities σχετικά με την εκτέλεση εντολών από την είσοδο (πχ cmd_l για την εντολή l, cmd_m για την m κτλ). 
		Το loop που αναφέρθηκε προηγουμένως καλεί την συνάρτηση exec_cmd με όρισμα το πρώτο argument της εντολής του χρήστη, και, κάνοντας 
		τον κατάλληλο έλεγχο καλεί την σωστή συνάρτηση από τις cmd_l, cmd_i,...,κτλ (λειτουργεί δηλαδή σαν μια δομή switch για την είσοδο 
		του χρήστη).

--> Σημεία ιδιαίτερης σημασίας, τεχνικές λεπτομέρειες

	* Η δομή ανεστραμμένου καταλόγου διατηρείται sorted μετά από κάθε voter V insertion, με τον εξής αλγόριθμο:
		i)   Δες πρώτα αν υπάρχει ήδη το zipcode_node (κόμβος της οριζόντιας λίστας) με το ίδιο Τ.Κ. του V. 
		Αν δεν υπάρχει, τότε απλά δημιούργησε έναν στην ουρά της οριζόντιας λίστας και βάλε εκεί τον V. Εδώ τα πράγματα είναι απλά καθώς
		δεν χρειάζεται κάποια επιπλέον ενέργεια. 
		ii)  Μια άλλη trivial περίπτωση σαν την i είναι να βρεθεί ο κόμβος αλλά αυτός να είναι ο head (ο πρώτος κόμβος της λίστας ο οποίος
		εκ κατασκευής της λίστας, θα έχει το μεγαλύτερο μέγεθος και πριν το insert του V). Επομένως, μετά το insert του V στον κόμβο head δεν
		χρειάζεται κάποια επιπλέον ενέργεια.
		iii) Αν υπάρχει και έστω ότι είναι ο Ζ, τότε αυτό που κάνουμε είναι να βάλουμε πρώτα τον V στο Ζ και να αυξήσουμε λοιπόν το μέγεθος του
		Ζ. Έπειτα, αποσυνδέουμε τον Z από την οριζόντια λίστα (doubled ended ll) διατηρώντας την υπόλοιπη δομή ίδια. 
		iv)  Τέλος πραγματοποιούμε μια μετακίνηση του Z προς τα αριστερά (προς το head), μέχρι να βρούμε την σωστή θέση i για αυτόν, όπου δηλαδή, 
		για πρώτη φορά θα ισχύει:
									_ Θέση i
								   /
								  V
			n_voters(Z_{i-1}) >= n_voters(Z) > n_voters(Z_{i+1}).
		
		Επομένως, αυτό που κάνουμε είναι ένα "έξυπνο" sorted insert.
	* Για τον υπολογισμό των συνολικών bytes που απελευθερώνονται κατά το exit της εφαρμογής (μετά την εντολή exit του χρήστη), έχει επιλεχθεί η
	εξής προσέγγιση:
		i)   Αρχικοποίησε μια global μεταβλητή size_t bytes_freed = 0 στο Command.c
		ii)  Στο cmd_exit κάλεσε την database_destroy
		iii) Η database_destroy, έπειτα, αναλαμβάνει να καλέσει τις συνάρτησεις inv_index_destroy, hash_table_destroy που καταστρέφουν και 
		απελευθερώνουν τα bytes που έχουν δεσμεύσει οι δομές ανεστραμμένου καταλόγου και γραμμικού κατακερματισμού αντίστοιχα. Γενικότερα, 
		μετά από τα αντίστοιχα frees, προσθέτουμε τα bytes που απελευθερώνονται στην μεταβλητή bytes_freed, πχ: 

			free(Voter);
			bytes_freed += sizeof(struct voter);

		iv) Προσέχουμε, όμως, να μην προσθέσουμε τα bytes μετά από frees που δεν γίνονται κατά το exit, πχ κατά το destroy της βοηθητικής 
		λίστας για το redistribution των keys στον insertion στο γραμμικό κατακερματισμό. Για αυτό τον λόγο ορισμένες συνάρτησεις όπως για 
		παράδειγμα η list_destroy, η bucket_list_destroy, η bucket_destroy έχουν ως όρισμα και το flag: bool count_bytes. Αν το count_bytes 
		είναι false, τότε δεν προσθέτουμε τα freed bytes, σε αντίθετη περίπτωση τα προσθέτουμε. 
		v) Τελικά η μεταβλητή bytes_freed φυλά την παραπάνω επιθυμητή ποσότητα και απλά την εκτυπώνουμε.
	* Όπως ειπώθηκε και προηγουμένως, η δομή του γραμμικού κατακερματισμού υλοποιήθηκε με βάση το βοηθητικό υλικό που συνοδεύει αυτή την εργασία.
	Επομένως, σχετικά με το search και insert operation σε αυτή την δομή δεν γίνεται κάποια αναφορά για τους αλγορίθμους καθώς αυτοί (οι αλγόριθμοι)
	αποτελούν 1-1 μετάφραση από το παράδειγμα του paper στον κώδικα (βλ. κώδικα για περισσότερες λεπτομέρειες στους αλγόριθμους της δομής γραμμικού 
	κατακερματισμού). Επιπλέον, πολλές ονομασίες σε σημαντικές μεταβλητές, όπως πχ το m (το αρχικό μέγεθος του hash table) έχουν παρθεί από εκεί 
	(το paper), σε διάφορα σημεία του κώδικα (όχι απαραίτητα όλα τα σημεία που εμφανίζονται οι συγκεκριμένοι όροι). Με την ίδια λοιπόν παραδοχή, 
	προέκυψαν και οι ονομασίες των μεταβλητών: p_index, lambda, της ίδιας δομής.
	* Όλες οι δομές που έχουν υλοποιηθεί στην εργασία αυτή, πέραν της απλά συνδεδεμένης λίστας (LinkedList), ΔΕΝ είναι generic. Δηλαδή, 
	λειτουργούν μόνο με item: Voter.
	* Παρόλο που υλοποιήθηκε η δομή της συνδεδεμένης λίστας ως generic, επιλέχθηκε να μην χρησιμοποιηθεί αυτή για τις λίστες των buckets και την 
	zipcode_node_list των δομών HashTable, InvertedIndex αντίστοιχα. Ο λόγος ήταν για να κρατηθεί απλός ο κώδικας στα modules αυτά και για να
	μην τροποποιηθεί σε μεγάλο βαθμό το LinkedList module αφού για τους στόχους της εργασίας ήταν πολύ list-specific τα operations που έπρεπε 
	να μπορούν να γίνονται. Αντ' αυτού, το τελευταίο module χρησιμοποιήθηκε σε συγκεκριμένα σημεία, όπως πχ:
		i)  Για την προσωρινή αποθήκευση των Voters κατα το redistribution stage στο hash_table_insert.
		ii) Για τις κάθετες λίστες των Voters στους zipcode_nodes του InvertedIndex.

Γ) Επεξήγηση πολυπλοκότητας

Σε αυτό το section Θα γίνει μια σύντομη αναφορά των πολυπλοκοτήτων ορισμένων εντολών. Δεν θα μπούμε σε πολύ λεπτομέρεια σε σχέση με το πως 
προκύπτουν τα τελικά αποτελέσματα της κάθε περίπτωσης, αφού οι πράξεις big O θεωρούνται τετριμμένες. Εκεί που θα δώσουμε έμφαση είναι πως έχουν 
προκύψει οι επιμέρους πολυπλοκότητες βάσει των σχεδιαστικών επιλογών που έχουν γίνει για τις δομές της βάσης καθώς και των αλγορίθμων που 
συνοδεύουν αυτές τις δομές. Αφετηρία για αυτή την σύντομη μελέτη θα είναι οι εντολές του χρήστη και θα κατεβαίνουμε προς τις δομές της βάσης 
(top down προσέγγιση).

--> εντολή i: amortized O(1)
	* Η δημιουργία του voter V με τα στοιχεία αυτά της εισόδου πραγματοποιείται σε Ο(1).
	* Η εισαγωγή του V στην βάση θεωρούμε ότι πραγματοποιείται σε Ο(1), αφού έχουμε υλοποιήσει μια δομή γραμμικού κατακερματισμού
	για την αποθήκευση των voters, με βάση το paper. Δεν θα γίνουν περισσότερες αναφορές για τα μαθηματικά από πίσω και για
	το γιατί είναι Ο(1), καθώς δεν θεωρώ ότι είναι ο σκοπός αυτός, αυτής της εργασίας. Επομένως, θα θεωρούμε -αξιωματικά- ότι 
	αυτή είναι η πολυπλοκότητα της hash_table_insert.

--> εντολή l: O(1)
	* Για τους ίδιους λόγους με παραπάνω και θεωρώντας ότι έχει υλοποιηθεί σωστά η δομή του γραμμικού κατακερματισμού, θα θεωρούμε
	αξιωματικά την πολυπλοκοτήτα αναζήτησης (hash_table_seach) ίση με O(1).

--> εντολή o: O(n), όπου n το πλήθος των Τ.Κ. των ψηφοφόρων που έχουν ψηφίσει
	Εφόσον έχουμε διατηρήσει την δομή του ανεστραμμένου καταλόγου ταξινομημένη σε φθίνουσα σειρά, αρκεί η επίσκεψη του κάθε zipcode_node 
	από το head μέχρι το tail αυτής της δομής.

--> εντολή m: O(n)
	* Η εύρεση του voter με pin αυτό της εισόδου καθώς και το μαρκάρισμα του σε voted γίνεται σε O(1) (hash_table_search).
	* Όμως, στην περίπτωση που βρεθεί και δεν ήταν ήδη voted, θα πρέπει να μπει και στην δομή του ανεστραμμένου καταλόγου. Ο αλγόριθμος για 
	αυτό το insertion περιγράφηκε προηγουμένως. Η πολυπλοκότητα χείριστης περίπτωσης αυτού του αλγορίθμου είναι O(n), όπου n το πλήθος των 
	διαφορετικών Τ.Κ. των ψηφοφόρων που έχουν ψηφίσει. 
	* Η περίπτωση αυτή είναι εφικτή αν σε ένα δεδομένο instance του InvertedIndex, έχουμε μεγάλο αριθμό (τήνει στο μέγεθος της
	οριζόντιας λίστας, έστω n) από zipcode_nodes που έχουν το ίδιο μέγεθος και μετά από το insertion αυξάνεται το μέγεθος κατά +1
	του τελευταίου από αυτούς. Επομένως, κατά το sorted insert, θα πρέπει να μετακινηθεί ~ n φορές αριστερά.
	* Παρόλ' αυτά, αξίζει να σημειωθεί ότι, κάνοντας χρήση του doubled-ended ll, και λαμβάνοντας υπόψη ότι μετά από κάθε insertion σε αυτή 
	την δομή, ένας υπάρχον κόμβος μπορεί να αυξηθεί ακριβώς κατά 1 σε αριθμό voters, τότε, σε μια μέση, όσο το δυνατόν τυχαία 
	περίπτωση/instance του InvertedIndex, θεωρούμε ότι ο αλγόριθμος αυτός θα πραγματοποιήσει πολύ λιγότερες από n επισκέψεις σε zipcode_nodes.

--> εντολή v: O(1)
	* Ο αριθμός των ψηφοφόρων διατηρείται και ενημερώνεται μέσα στο struct του hash_table (n_voters_voted).

--> εντολή perc: O(1)
	* Ο αριθμός τόσο των ψηφοφόρων που έχουν ψηφίσει, όσο και εν' γένει όλων των ψηφοφόρων της βάσης, διατηρούνται και ενημερώνονται
	στο struct του hash_table (n_voters_voted, n_voters). Επομένως, απομένει μόνο ένας απλός υπολογισμός που θεωρούμε ότι πραγματοποιείται
	σε "χρόνο" Ο(1) (hash_table_perc).

Δ) Παραδοχές

	* Αν υπάρξει κάποιο malloc failure, τότε μετά την εκτύπωση σχετικού μηνύματος στο stderr κάνουμε απλά exit(EXIT_FAILURE), όπως και 
	προτείνεται να κάνουμε από σχετικό ποστ στο piazza.
	* Το μέγιστο μέγεθος (σε χαρακτήρες) ενός command του χρήστη είναι fixed στην τιμή 100 (#define INPUT_SIZE 100 στο Command.c). Στην
	περίπτωση που υπερβεί αυτό το μέγεθος, τότε, εκτυπώνουμε το error στο Errors.txt, καθαρίζουμε τον buffer (cleanInput) και κάνουμε 
	continue στο while loop μας.
	* Όλα τα αρχεία αρχικοποίησης της βάσης θα πρέπει να είναι στην ίδια μορφή με αυτή των αρχείων voters50/500/5000.csv της εκφώνησης.
	* Γενικότερα για το φιλτράρισμα των εντολών, έχουμε:
		i)   Στην περίπτωση που ο χρήστης πατήσει σκέτο enter, εκτυπώνεται "Malformed Input" και πάμε στο επόμενο input.
		ii)  Έλεγχος του buffer size, όπως ειπώθηκε παραπάνω.
		iii) Αν δοθεί σωστό πρώτο όρισμα (μια απο τις εντολές της εκφώνησεις m, l, ...κτλπ), και δεν δοθεί σωστό πλήθος
		ορισμάτων μετά (πχ στην εντολή m έχουμε άλλο 1 όρισμα το pin), τότε εκτυπώνεται "Malformed Input" και πάμε στο επόμενο input
		iv)  Αν δοθεί σωστό πρώτο όρισμα και κάποιο από τα ορίσματα πρέπει να είναι θετικός ακέραιος αλλά αυτό δεν είναι, τότε
		εκτυπώνεται "Malformed Input" και πάμε στο επόμενο input. Παρολ' αυτά αν το μέγεθος του φυσικού αριθμού είναι πολύ μεγάλο, τότε 
		το πρόγραμμα θα τερματίσει με assert λόγω του overflow, επομένως αυτή η υποπερίπτωση είναι ευθύνη του χρήστη. Επιπλέον, στις 
		περιπτώσεις που το αναμενόμενο argument είναι λέξη με γράμματα μόνο (πχ το όνομα ενός ψηφοφόρου), δεν γίνεται κάποιος έλεγχος 
		για το αν περιέχει αυτό ειδικούς χαρακτήρες ή αριθμούς, επομένως και αυτή η υποπερίπτωση είναι ευθύνη του χρήστη.
		v)   Αν δεν δοθεί καμία γνωστή εντολή (το πρώτο όρισμα δεν είναι ένα από τα m, l, ...κτλπ) τότε εκτυπώνεται "Malformed Input" και 
		πάμε στο επόμενο input.
	* Tα αρχεία της εντολής bv μπορεί να είναι και στην μορφή:
		<pin1> < more text here >
		<pin2> < more text here >
		<pin3> < more text here >
		... 
	Απλά θα διαβαστούν μόνο τα pin και η εντολή θα έχει το επιθυμητό αποτέλεσμα. Επομένως, θα λειτουργήσει σωστά και με το format του
	voters50.csv και με το format του vote50.csv που βρίσκονται στο tests directory. Αν όμως εντοπιστεί κάποιο malformed input, 
	για παράδειγμα, αν το πρώτο όρισμα που μας απασχολεί (pin) μιας γραμμής δεν είναι θετικός ακέραιος αριθμός, τότε -όπως προτείνεται 
	και στο piazza- τερματίζει η εντολή bv (έχοντας πρώτα κλείσει το αρχείο) και πάμε στο επόμενο input.
